"""Grammar quiz module with question types, session management, and mastery tracking."""

from __future__ import annotations

import json
from dataclasses import dataclass, field, asdict
from datetime import datetime
from enum import Enum
from typing import Any

from .paths import DATA_DIR, ensure_data_dir


# ---------------------------------------------------------------------------
# Quiz data file
# ---------------------------------------------------------------------------

QUIZ_DATA_FILE = DATA_DIR / "grammar_quiz_data.json"


# ---------------------------------------------------------------------------
# Question types
# ---------------------------------------------------------------------------

class QuestionType(str, Enum):
    FILL_IN_BLANK = "fill_in_blank"
    MULTIPLE_CHOICE = "multiple_choice"
    CONJUGATION = "conjugation"
    ERROR_CORRECTION = "error_correction"
    SENTENCE_TRANSFORMATION = "sentence_transformation"


QUESTION_TYPE_LABELS = {
    QuestionType.FILL_IN_BLANK: "Fill in the Blank",
    QuestionType.MULTIPLE_CHOICE: "Multiple Choice",
    QuestionType.CONJUGATION: "Conjugation Challenge",
    QuestionType.ERROR_CORRECTION: "Error Correction",
    QuestionType.SENTENCE_TRANSFORMATION: "Sentence Transformation",
}


# ---------------------------------------------------------------------------
# Dataclasses
# ---------------------------------------------------------------------------

@dataclass
class QuizQuestion:
    """A single quiz question generated by Claude."""

    question_text: str
    question_type: str  # QuestionType value
    correct_answer: str
    grammar_topic: str
    cefr_level: str
    options: list[str] = field(default_factory=list)  # for multiple choice
    hint: str = ""
    instruction: str = ""  # extra instruction per question type

    def to_dict(self) -> dict:
        return asdict(self)

    @classmethod
    def from_dict(cls, data: dict) -> QuizQuestion:
        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})


@dataclass
class QuizAnswer:
    """User's answer to a quiz question."""

    question: QuizQuestion
    user_answer: str
    correct: bool
    feedback: str  # explanation of the grammar rule
    score: float = 0.0  # 0.0 or 1.0 (partial credit possible for conjugation)

    def to_dict(self) -> dict:
        d = asdict(self)
        return d


@dataclass
class QuizSession:
    """An active quiz session."""

    topic: str
    cefr_level: str
    questions: list[QuizQuestion] = field(default_factory=list)
    answers: list[QuizAnswer] = field(default_factory=list)
    current_index: int = 0
    started_at: str = field(default_factory=lambda: datetime.now().isoformat())

    @property
    def total_questions(self) -> int:
        return len(self.questions)

    @property
    def is_complete(self) -> bool:
        return self.current_index >= self.total_questions

    @property
    def current_question(self) -> QuizQuestion | None:
        if self.current_index < self.total_questions:
            return self.questions[self.current_index]
        return None

    @property
    def score(self) -> float:
        if not self.answers:
            return 0.0
        return sum(a.score for a in self.answers) / len(self.answers) * 100

    @property
    def correct_count(self) -> int:
        return sum(1 for a in self.answers if a.correct)

    def score_by_type(self) -> dict[str, dict]:
        """Get score breakdown by question type."""
        by_type: dict[str, list[QuizAnswer]] = {}
        for a in self.answers:
            qt = a.question.question_type
            by_type.setdefault(qt, []).append(a)

        result = {}
        for qt, answers in by_type.items():
            correct = sum(1 for a in answers if a.correct)
            result[qt] = {
                "total": len(answers),
                "correct": correct,
                "score": correct / len(answers) * 100 if answers else 0,
            }
        return result

    def weak_areas(self) -> list[str]:
        """Return grammar topics where the user scored below 85%."""
        by_topic: dict[str, list[QuizAnswer]] = {}
        for a in self.answers:
            topic = a.question.grammar_topic
            by_topic.setdefault(topic, []).append(a)

        weak = []
        for topic, answers in by_topic.items():
            correct = sum(1 for a in answers if a.correct)
            if len(answers) > 0 and (correct / len(answers)) < 0.85:
                weak.append(topic)
        return weak


@dataclass
class QuizResult:
    """Saved result of a completed quiz session."""

    topic: str
    cefr_level: str
    questions_attempted: int
    correct: int
    score: float
    weak_areas: list[str]
    question_type_breakdown: dict[str, dict]
    completed_at: str = field(default_factory=lambda: datetime.now().isoformat())

    def to_dict(self) -> dict:
        return asdict(self)

    @classmethod
    def from_session(cls, session: QuizSession) -> QuizResult:
        return cls(
            topic=session.topic,
            cefr_level=session.cefr_level,
            questions_attempted=len(session.answers),
            correct=session.correct_count,
            score=session.score,
            weak_areas=session.weak_areas(),
            question_type_breakdown=session.score_by_type(),
        )


# ---------------------------------------------------------------------------
# Mastery tracking (persistent)
# ---------------------------------------------------------------------------

MASTERY_THRESHOLD = 85.0  # percent


def load_quiz_data() -> dict:
    """Load persistent quiz data (mastery tracking, history)."""
    ensure_data_dir()
    if not QUIZ_DATA_FILE.exists():
        return {
            "mastery": {},  # topic -> {quizzed_count, avg_score, last_quiz, mastered}
            "history": [],  # list of QuizResult dicts
        }
    try:
        with open(QUIZ_DATA_FILE) as f:
            return json.load(f)
    except (json.JSONDecodeError, IOError):
        return {"mastery": {}, "history": []}


def save_quiz_data(data: dict) -> None:
    """Save quiz data to disk."""
    ensure_data_dir()
    with open(QUIZ_DATA_FILE, "w") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)


def record_quiz_result(result: QuizResult) -> dict:
    """Record a quiz result and update mastery tracking.

    Returns the updated mastery entry for the topic.
    """
    data = load_quiz_data()

    # Update history
    data["history"].append(result.to_dict())
    # Keep last 100 results
    data["history"] = data["history"][-100:]

    # Update mastery for the topic
    topic = result.topic
    mastery = data["mastery"].get(topic, {
        "quizzed_count": 0,
        "avg_score": 0.0,
        "last_quiz": None,
        "mastered": False,
        "cefr_level": result.cefr_level,
    })

    # Compute running average
    old_count = mastery["quizzed_count"]
    old_avg = mastery["avg_score"]
    new_count = old_count + 1
    new_avg = (old_avg * old_count + result.score) / new_count

    mastery["quizzed_count"] = new_count
    mastery["avg_score"] = round(new_avg, 1)
    mastery["last_quiz"] = result.completed_at
    mastery["cefr_level"] = result.cefr_level
    mastery["mastered"] = new_avg >= MASTERY_THRESHOLD

    data["mastery"][topic] = mastery
    save_quiz_data(data)
    return mastery


def get_topic_mastery() -> dict[str, dict]:
    """Get mastery data for all topics."""
    data = load_quiz_data()
    return data.get("mastery", {})


def get_quiz_history(limit: int = 10) -> list[dict]:
    """Get recent quiz history."""
    data = load_quiz_data()
    history = data.get("history", [])
    return history[-limit:]


# ---------------------------------------------------------------------------
# Grammar topics by CEFR level (used for topic selection menu)
# ---------------------------------------------------------------------------

GRAMMAR_TOPICS: dict[str, list[str]] = {
    "A1": [
        "Present tense - regular verbs",
        "Ser vs Estar",
        "Gender and number agreement",
        "Definite and indefinite articles",
        "Basic question formation",
        "Possessive adjectives",
        "Common irregular verbs (ir, tener, hacer)",
        "Hay (there is/there are)",
        "Basic prepositions (en, de, a, con)",
        "Gustar and similar verbs",
    ],
    "A2": [
        "Preterite tense - regular verbs",
        "Preterite tense - irregular verbs",
        "Imperfect tense",
        "Preterite vs Imperfect",
        "Reflexive verbs",
        "Direct object pronouns",
        "Indirect object pronouns",
        "Double object pronouns",
        "Comparatives and superlatives",
        "Present progressive (estar + gerund)",
        "Imperative mood - affirmative commands",
        "Por vs Para",
    ],
    "B1": [
        "Present subjunctive - regular",
        "Present subjunctive - irregular",
        "Subjunctive triggers (querer que, es importante que...)",
        "Subjunctive vs Indicative",
        "Conditional tense",
        "Future tense",
        "Relative pronouns (que, quien, donde)",
        "Passive voice (ser + past participle)",
        "Se impersonal / se pasiva",
        "Past participle as adjective",
        "Imperative mood - negative commands",
        "Adverbial clauses with subjunctive",
    ],
    "B2": [
        "Imperfect subjunctive",
        "Si clauses (conditionals)",
        "Conditional perfect",
        "Pluperfect (past perfect)",
        "Future perfect",
        "Pluperfect subjunctive",
        "Sequence of tenses",
        "Advanced passive constructions",
        "Relative clauses with prepositions",
        "Subjunctive in adjective clauses",
        "Reported speech",
        "Advanced uses of se",
    ],
}


# ---------------------------------------------------------------------------
# Question generation prompt for Claude
# ---------------------------------------------------------------------------

def build_quiz_generation_prompt(
    topic: str,
    cefr_level: str,
    count: int,
    question_types: list[str] | None = None,
    known_vocabulary: list[str] | None = None,
) -> str:
    """Build the prompt that asks Claude to generate quiz questions."""
    if question_types is None:
        question_types = [qt.value for qt in QuestionType]

    type_descriptions = {
        "fill_in_blank": 'Fill-in-the-blank: Provide a sentence with a blank _____ and the verb/word in parentheses. User fills in the correct conjugated/agreed form. Example: "Ayer yo _____ (ir) al supermercado." Answer: "fui"',
        "multiple_choice": "Multiple choice: Provide a question with exactly 4 options labeled A, B, C, D. Only one is correct.",
        "conjugation": "Conjugation challenge: Ask the user to conjugate a specific verb in a specific tense for all persons (yo, tu, el/ella, nosotros, vosotros, ellos/ellas). Correct answer should be all 6 forms separated by commas.",
        "error_correction": 'Error correction: Provide a sentence with a grammar error. The user must identify and fix it. Example: "Yo soy cansado." -> "Yo estoy cansado."',
        "sentence_transformation": 'Sentence transformation: Give a sentence and ask the user to transform it (change tense, mood, etc.). Example: "Rewrite in the preterite: Yo como pizza." -> "Yo comi pizza."',
    }

    types_text = "\n".join(
        f"- {type_descriptions[qt]}"
        for qt in question_types
        if qt in type_descriptions
    )

    vocab_text = ""
    if known_vocabulary:
        sample = known_vocabulary[:50]
        vocab_text = f"\n\nThe user already knows these Spanish words (use them in sentences so grammar is the focus, not vocabulary): {', '.join(sample)}"

    return f"""Generate exactly {count} Spanish grammar quiz questions about "{topic}" at CEFR {cefr_level} level.

Question types to use (distribute evenly across these types):
{types_text}
{vocab_text}

IMPORTANT: Return ONLY valid JSON, no markdown formatting. Return a JSON array of question objects with this exact structure:
[
  {{
    "question_text": "the question displayed to the user",
    "question_type": "fill_in_blank|multiple_choice|conjugation|error_correction|sentence_transformation",
    "correct_answer": "the correct answer",
    "options": ["A) ...", "B) ...", "C) ...", "D) ..."],
    "hint": "optional hint",
    "instruction": "brief instruction for this question type",
    "grammar_topic": "{topic}",
    "cefr_level": "{cefr_level}"
  }}
]

Rules:
- For multiple_choice: options must be exactly 4 items, correct_answer must match one option exactly
- For fill_in_blank: include the word to conjugate/use in parentheses within the question
- For conjugation: correct_answer should be "yo X, tu X, el/ella X, nosotros X, vosotros X, ellos/ellas X"
- For error_correction: question_text is the sentence with the error, correct_answer is the corrected sentence
- For sentence_transformation: include the transformation instruction in the question_text
- Make questions progressively harder within the set
- Include a brief grammar explanation in the hint field
- All content in Spanish (questions) with English instructions"""


def parse_quiz_questions(response_text: str) -> list[QuizQuestion]:
    """Parse Claude's JSON response into QuizQuestion objects."""
    # Try to extract JSON array from the response
    text = response_text.strip()

    # Handle markdown code blocks
    if "```json" in text:
        text = text.split("```json")[1].split("```")[0].strip()
    elif "```" in text:
        text = text.split("```")[1].split("```")[0].strip()

    # Find the JSON array
    start = text.find("[")
    end = text.rfind("]")
    if start == -1 or end == -1:
        raise ValueError("No JSON array found in response")

    json_str = text[start : end + 1]
    raw_questions = json.loads(json_str)

    questions = []
    for raw in raw_questions:
        questions.append(QuizQuestion(
            question_text=raw.get("question_text", ""),
            question_type=raw.get("question_type", "fill_in_blank"),
            correct_answer=raw.get("correct_answer", ""),
            grammar_topic=raw.get("grammar_topic", ""),
            cefr_level=raw.get("cefr_level", ""),
            options=raw.get("options", []),
            hint=raw.get("hint", ""),
            instruction=raw.get("instruction", ""),
        ))
    return questions


def build_grading_prompt(question: QuizQuestion, user_answer: str) -> str:
    """Build a prompt for Claude to grade a single answer."""
    return f"""Grade this Spanish grammar quiz answer. Be lenient with accent marks and minor typos, but strict on grammar correctness.

Question type: {question.question_type}
Question: {question.question_text}
Correct answer: {question.correct_answer}
User's answer: {user_answer}

Return ONLY valid JSON with this structure:
{{
  "correct": true/false,
  "score": 0.0 to 1.0 (1.0 = fully correct, 0.5 = partially correct for conjugation tables),
  "feedback": "Brief explanation of the grammar rule and why the answer is correct/incorrect. In English with Spanish examples."
}}"""
